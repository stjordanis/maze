<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
<title>Susam's Linux Maze</title>
<link>https://susam.in/maze/</link>
<atom:link href="https://susam.in/maze/rss.xml"
           rel="self" type="application/rss+xml"/>
<description>Feed from Susam's Linux Maze</description>

<item>
<title>Of Course "changeme" Is Valid Base64</title>
<link>https://susam.in/maze/of-course-changeme-is-valid-base64.html</link>
<guid>https://susam.in/maze/of-course-changeme-is-valid-base64.html</guid>
<description>
<![CDATA[
<p>
  Today, I came across
  this <a href="https://3fx.ch/blog/2019/12/09/changeme-is-valid-base64/">blog
  post</a> regarding how the author of the post used the
  string <code>"changeme"</code> as test data while testing a Base64
  decoding functionality in their application. However, the author
  incorrectly believed that this test data is not a valid
  Base64-encoded string and therefore would fail to decode
  successfully when decoded as Base64. To their surprise, they found
  that this string <code>"changeme"</code> does in fact decode
  successfully.
</p>
<p>
  The post did not go any further into understanding why
  indeed <code>"changeme"</code> is a valid Base64-encoded string and
  why it can successfully be decoded into binary data. It appears that
  the author was using Base64 encoding scheme as a black box.
</p>
<p>
  I think it is worth noting and illustrating that any alphanumeric
  string with a length that is a multiple of 4 is a valid
  Base64-encoded string. Here are some examples that illustrate this:
</p>
<pre>
<samp>$ <kbd>printf AAAA | base64 --decode | od -tx1</kbd>
0000000    00  00  00
0000003
$ <kbd>printf AAAAAAAA | base64 --decode | od -tx1</kbd>
0000000    00  00  00  00  00  00
0000006
$ <kbd>printf AQEB | base64 --decode | od -tx1</kbd>
0000000    01  01  01
0000003
$ <kbd>printf AQID | base64 --decode | od -tx1</kbd>
0000000    01  02  03
0000003
$ <kbd>printf main | base64 --decode | od -tx1</kbd>
0000000    99  a8  a7
0000003
$ <kbd>printf scrabble | base64 --decode | od -tx1</kbd>
0000000    b1  ca  da  6d  b9  5e
0000006
$ <kbd>printf 12345678 | base64 --decode | od -tx1</kbd>
0000000    d7  6d  f8  e7  ae  fc
0000006</samp>
</pre>
<p>
  Further, since <code>+</code> and <code>/</code> are also used as
  symbols in Base64 encoding (for binary <code>111110</code>
  and <code>111111</code>, respectively), we also have a few more
  intersting examples:
</p>
<pre>
<samp>$ <kbd>printf 1+2+3+4+5/11 | base64 --decode | od -tx1</kbd>
0000000    d7  ed  be  df  ee  3e  e7  fd  75
0000011
$ <kbd>printf "\xd7\xed\xbe\xdf\xee\x3e\xe7\xfd\x75" | base64</kbd>
1+2+3+4+5/11</samp>
</pre>
<p>
  I think it is good to understand why any string with a length that
  is a multiple of 4 turns out to be a valid Base64-encoded string.
  The Base64 encoding scheme encodes each group of 6 bits in the
  binary input with a chosen ASCII character. For every possible 6-bit
  binary value, we have assigned an ASCII character that appears in
  the Base64-encoded string. Each output ASCII character can be one of
  the 64 carefully chosen ASCII characters: lowercase and uppercase
  letters from the English alphabet, the ten digits from the Arabic
  numerals, the plus sign (<code>+</code>) and the forward slash
  (<code>/</code>). For example, the bits <code>000000</code> is
  encoded as <code>A</code>, the bits <code>000001</code> is encoded
  as <code>B</code>, and so on. The equals sign (<code>=</code>) is
  used for padding but that is not something we will discuss in detail
  in this post.
</p>
<p>
  The smallest positive multiple of 6 that is also a multiple of 8 is
  24. Thus every group of 3 bytes (24 bits) of binary data is
  translated to 4 ASCII characters in its Base64-encoded string. Thus
  the entire input data is divided into groups of 3 bytes each and
  then each group of 3 bytes is encoded into 4 ASCII characters. What
  if the last group is less than 3 bytes long? There are certain
  padding rules for such cases but I will not discuss them right now
  in this post. For more details on the padding rules,
  see <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC
  4648</a>.
</p>
<p>
  Now as a natural result of the encoding scheme, it turns out that
  any 4 alphanumeric characters is a valid Base64 encoding of some
  binary data. That's because for every alphanumeric character, we can
  find some 6-bit binary data that would be translated to it during
  Base64 encoding. This is the reason why any alphanumeric string with
  a length that is a multiple of 4 is a valid Base64-encoded string
  and can be successfully decoded to some binary data.
</p>


<p><a href="https://susam.in/maze/of-course-changeme-is-valid-base64.html">Read on website</a></p>
]]>
</description>
<pubDate>Sat, 24 Oct 2020 00:00:00 +0000</pubDate>
</item>
<item>
<title>Unix Timestamp 1600000000</title>
<link>https://susam.in/maze/unix-timestamp-1600000000.html</link>
<guid>https://susam.in/maze/unix-timestamp-1600000000.html</guid>
<description>
<![CDATA[
<p>
  At 2020-09-13 12:26:40 UTC, the Unix timestamp is going to turn
  1600000000.
</p>

<h2 id="unix-timestamp-conversion">Unix Timestamp Conversion<a href="#unix-timestamp-conversion"></a></h2>
<p>
  The following subsections show a few examples of converting the Unix
  timestamp to a human-readable date.
</p>

<h3 id="python">Python<a href="#python"></a></h3>
<pre>
<samp>$ <kbd>python3 -q</kbd>
>>> <kbd>from datetime import datetime</kbd>
>>> <kbd>datetime.utcfromtimestamp(1_600_000_000)</kbd>
datetime.datetime(2020, 9, 13, 12, 26, 40)</samp>
</pre>

<h3 id="gnu-date">GNU date (Linux)<a href="#gnu-date"></a></h3>
<pre>
<samp>$ <kbd>date -ud @1600000000</kbd>
Sun Sep 13 12:26:40 UTC 2020</samp>
</pre>

<h3 id="bsd-date">BSD date (macOS, FreeBSD, OpenBSD, etc.)<a href="#bsd-date"></a></h3>
<pre>
<samp>$ <kbd>date -ur 1600000000</kbd>
Sun Sep 13 12:26:40 UTC 2020</samp>
</pre>

<h2 id="other-such-dates">Other Such Dates<a href="#other-such-dates"></a></h2>
<p>
All such dates (in UTC) until the end of the current century:
</p>
<pre>
$ <kbd>python3 -q</kbd>
>>> <kbd>from datetime import datetime</kbd>
>>> <kbd>for t in range(0, 4_200_000_000, 100_000_000):</kbd>
... <kbd>    print(f'{t:13_d} - {datetime.utcfromtimestamp(t)}')
...
            0 - 1970-01-01 00:00:00
  100_000_000 - 1973-03-03 09:46:40
  200_000_000 - 1976-05-03 19:33:20
  300_000_000 - 1979-07-05 05:20:00
  400_000_000 - 1982-09-04 15:06:40
  500_000_000 - 1985-11-05 00:53:20
  600_000_000 - 1989-01-05 10:40:00
  700_000_000 - 1992-03-07 20:26:40
  800_000_000 - 1995-05-09 06:13:20
  900_000_000 - 1998-07-09 16:00:00
1_000_000_000 - 2001-09-09 01:46:40
1_100_000_000 - 2004-11-09 11:33:20
1_200_000_000 - 2008-01-10 21:20:00
1_300_000_000 - 2011-03-13 07:06:40
1_400_000_000 - 2014-05-13 16:53:20
1_500_000_000 - 2017-07-14 02:40:00
1_600_000_000 - 2020-09-13 12:26:40
1_700_000_000 - 2023-11-14 22:13:20
1_800_000_000 - 2027-01-15 08:00:00
1_900_000_000 - 2030-03-17 17:46:40
2_000_000_000 - 2033-05-18 03:33:20
2_100_000_000 - 2036-07-18 13:20:00
2_200_000_000 - 2039-09-18 23:06:40
2_300_000_000 - 2042-11-19 08:53:20
2_400_000_000 - 2046-01-19 18:40:00
2_500_000_000 - 2049-03-22 04:26:40
2_600_000_000 - 2052-05-22 14:13:20
2_700_000_000 - 2055-07-24 00:00:00
2_800_000_000 - 2058-09-23 09:46:40
2_900_000_000 - 2061-11-23 19:33:20
3_000_000_000 - 2065-01-24 05:20:00
3_100_000_000 - 2068-03-26 15:06:40
3_200_000_000 - 2071-05-28 00:53:20
3_300_000_000 - 2074-07-28 10:40:00
3_400_000_000 - 2077-09-27 20:26:40
3_500_000_000 - 2080-11-28 06:13:20
3_600_000_000 - 2084-01-29 16:00:00
3_700_000_000 - 2087-04-01 01:46:40
3_800_000_000 - 2090-06-01 11:33:20
3_900_000_000 - 2093-08-01 21:20:00
4_000_000_000 - 2096-10-02 07:06:40
4_100_000_000 - 2099-12-03 16:53:20</samp>
</pre>

<h2 id="update">Update<a href="#update"></a></h2>
<p>
  Here is a screenshot I took at Unix timestamp 1600000000:
  <a href="https://twitter.com/susam/status/1305120936098627589">twitter.com/susam/status/130512093609862758</a>.
</p>
<p>
Reproduced as text below:
</p>
<pre>
<samp>$ <kbd>date -u; date; date +%s</kbd>
Sun Sep 13 12:26:39 UTC 2020
Sun Sep 13 17:56:39 IST 2020
1599999999
$ <kbd>date -u; date; date +%s</kbd>
Sun Sep 13 12:26:40 UTC 2020
Sun Sep 13 17:56:40 IST 2020
1600000000</samp>
</pre>
<p>
An important point worth noting from the POSIX.1-2008 specification:
</p>
<blockquote>
Coordinated Universal Time (UTC) includes leap seconds. However, in
POSIX time (seconds since the Epoch), leap seconds are ignored (not
applied) to provide an easy and compatible method of computing time
differences. Broken-down POSIX time is therefore not necessarily UTC,
despite its appearance.
</blockquote>
<p>
See <a href="https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16">&sect;
A.4.16</a> of the POSIX.1-2008 specification for more details.
</p>

<p><a href="https://susam.in/maze/unix-timestamp-1600000000.html">Read on website</a></p>
]]>
</description>
<pubDate>Sat, 12 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
<title>Debian Releases and Toy Story</title>
<link>https://susam.in/maze/debian-releases-and-toy-story.html</link>
<guid>https://susam.in/maze/debian-releases-and-toy-story.html</guid>
<description>
<![CDATA[
<p>
  Did you know that Debian releases are named after characters from
  the <em>Toy</em> Story films? I began using it with Debian 4 (Etch)
  in 2007. It was named after Etch A Sketch, one of Andy's toys. The
  latest release, Debian 10 (Buster), is named after Andy's pet puppy.
</p>
<p>
  The name Debian itself is a portmanteau of the names Ian Murdock
  (the creator of Debian) and Debra Lynn (his then-girlfriend, later
  ex-wife). As a result, this name has been called a <em>curiously
  personal name for such a community-oriented project</em>.
</p>
<p>
  I was using Fedora and Ubuntu in 2007 when a member of a local Linux
  User Group (LUG) introduced me to Debian. Its simplicity and
  elegance, its vast package repository, and its stability and
  robustness made me an ardent user of this distribution pretty
  quickly. Thirteen years later, I still use Debian on my laptops,
  Linode servers, and virtual machines. I run
  my <a href="https://susam.in/">personal website</a> on Debian too. I
  have got so used to <code>apt-get install</code> and the large
  number of tools available in the Debian repositories that I keep a
  Debian virtual machine or a remote shell handy when I am working on
  a non-Debian system. Over these years, I have gradually moved from
  GNOME 2 to GNOME 3 and then to Xfce 4. It really helps that Debian
  still provides an installation CD with Xfce as the default. In case
  anyone is interested, I have documented and shared
  my <a href="https://github.com/susam/dotfiles/blob/master/docs/debian-setup.md">Debian
  setup notes on GitHub</a>.
</p>

<p><a href="https://susam.in/maze/debian-releases-and-toy-story.html">Read on website</a></p>
]]>
</description>
<pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
</item>
<item>
<title>Fork Bunny</title>
<link>https://susam.in/maze/fork-bunny.html</link>
<guid>https://susam.in/maze/fork-bunny.html</guid>
<description>
<![CDATA[
<p>
  Have a close look at this line of shell command that can be executed
  on Bash, Zsh, and most POSIX or POSIX-like shells:
</p>
<pre><code>: () { : | : & } ; :</code></pre>
<p>
  Beware! Don't execute it on your system without understanding the
  consequences completely. If the command above looks puzzling, that
  is because it is deliberately obfuscated. Let us simplify it.
</p>
<p>
  The <code>:</code> is a function name. It could very well have
  been <code>f</code>. Let us replace <code>:</code>
  with <code>f</code> and see what the code now looks like.
</p>
<pre><code>f () { f | f & } ; f</code></pre>
<p>
Now it looks familiar. We have two commands separated by a semicolon.
Written in a more legible manner, the code would look like this:
</p>
<pre>
<code>f()
{
    f | f &
}

f</code>
</pre>
<p>
  It creates a function <code>f</code> and then executes it. This
  function calls itself twice recursively. The control
  operator <code>&</code> executes the recursive calls
  to <code>f</code> asynchronously, i.e., in the background. The
  number of instances of the function executing keeps growing
  exponentially thereby depleting CPU cycles and memory. The system is
  rendered unusable soon.
</p>
<p>
  This type of denial-of-service attack by self-replication is also
  known as a <em>fork bunny</em> which is a specific type
  of <em>wabbit</em>. See the following entry in the Jargon File for
  more information on
  this: <a href="http://catb.org/~esr/jargon/html/W/wabbit.html">wabbit</a>.
</p>

<p><a href="https://susam.in/maze/fork-bunny.html">Read on website</a></p>
]]>
</description>
<pubDate>Sun, 11 Jun 2006 00:00:00 +0000</pubDate>
</item>
<item>
<title>Vim Sudo Write Trick</title>
<link>https://susam.in/maze/vim-sudo-write-trick.html</link>
<guid>https://susam.in/maze/vim-sudo-write-trick.html</guid>
<description>
<![CDATA[
<h2 id="trick">The Trick<a href="#trick"></a></h2>
<p>
  You open a file, edit it, and save it only to get the E45 error
  message that says:
</p>
<pre><samp>E45: 'readonly' option is set (add ! to override)</samp></pre>
<p>
  You now realize that only root can edit the file. What do you? Start
  over? No, instead try this:
</p>
<pre><code>:w !sudo tee "%"</code></pre>
<p>
  I learnt this trick recently from the comment section
  of <a href="https://web.archive.org/web/20051120054527/http://www.vim.org/tips/tip.php?tip_id=975">Tip #975</a>
  on the Vim Tips website.
</p>

<h2 id="explanation">Explanation<a href="#explanation"></a></h2>
<p>
  How does the <code>:w !sudo tee "%"</code> trick work? Let us look
  at the command part-by-part:
</p>
<ul>
  <li>
    <p><code>:w !{cmd}</code></p>
    <p>
      Execute <code>{cmd}</code> with all lines in buffer as standard
      input.
    </p>
  </li>
  <li>
    <p><code>"%"</code></p>
    <p>
      The <code>%</code> is replaced with the current filename. The
      quotes around it keeps the filename as a single argument even if
      it contains whitespace.
    </p>
  </li>
  <li>
    <p><code>tee {file}</code></p>
    <p>
      The <code>tee</code> command is a Unix command (not a Vim
      command). It copies standard input to standard output
      and <code>{file}</code>.
    </p>
  </li>
</ul>

<h2 id="more">More Information<a href="#more"></a></h2>
<p>
  For more information on this command, enter the following commands
  in Vim:
</p>
<pre>
<code>:help :w_c
:help current-file
:help :_%</code>
</pre>
<p>
  Also, enter the following command in shell:
</p>
<pre><code>man tee</code></pre>
<p>
  I hope this was fun!
</p>

<p><a href="https://susam.in/maze/vim-sudo-write-trick.html">Read on website</a></p>
]]>
</description>
<pubDate>Thu, 25 Aug 2005 00:00:00 +0000</pubDate>
</item>


</channel>
</rss>
