<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
<title>Susam's Security Maze</title>
<link>https://susam.in/maze/</link>
<atom:link href="https://susam.in/maze/rss.xml"
           rel="self" type="application/rss+xml"/>
<description>Feed from Susam's Security Maze</description>

<item>
<title>UID Numbering Scheme</title>
<link>https://susam.in/maze/uid-numbering-scheme.html</link>
<guid>https://susam.in/maze/uid-numbering-scheme.html</guid>
<description>
<![CDATA[
<p>
Some thoughts
on <a href="http://web.archive.org/web/20100704211109/www.uidai.gov.in/documents/A_UID_Numbering_Scheme.pdf">A
UID Numbering Scheme</a> published
by <a href="http://web.archive.org/web/20100523144720/http://uidai.gov.in/">Unique
    Identification Authority of India (UIDAI)</a>.
</p>
<ol>
  <li>
    <p>
      <strong>Process for De-duplication</strong> (page 5):
    </p>
    <blockquote>
      Since biometric information contain no ordering and hence cannot
      be indexed like text based information, when a resident applies
      for a UID with his/her fingerprints, iris and photo of face,
      these biometrics have to be compared against the entire UID
      database (existing residents with UIDs) to ensure that this new
      applicant is indeed unique and has not already been allotted a
      UID (even under a different name, address etc). This 1:N
      biometric comparison (N=size of the UID database) is the most
      compute intensive operation of the UID server systeem.
    </blockquote>
    <p>
      It sounds as if the search operation would take O(N) time. Why
      can't the data be treated as binary numbers that can be ordered
      and indexed? It'll improve the search time to at least O(log N)
      time and possibly even further to O(1) time if a hashtable is
      used. The performance improvement is going to be huge since N is
      as large as 1.2 billion.
    </p>
  </li>
  <li>
    <p>
      <strong>Memorization of UID</strong> (page 6):
    </p>
    <blockquote>
      This section is about how long the string length should be. In
      short, the string has to be as short as possible but that meets
      density requirement and does not include alphabet characters,
      just numbers. It is important to keep the UID simple and small
      to help residents to remember their number.
    </blockquote>
    <blockquote>
      Firstly the use of the hindu-arabic numeral
      system(0,1,2,3,4,5,6,7,8,9) is suggested since these numerals
      are recognized/used by the largest subset of people in the
      country. Secondly we suggest the use of 12 digits (11 + 1 check
      sum) since 11 digits gives us a 100 billion number space which in
      turn can provide a low density of used numbers.
    </blockquote>
    <p>
      I don't think a 12 digit UID is easy to memorize. However, I
      agree that this length is necessary to ensure unique UIDs for a
      large population like India's. The population of India is about
      1.2 billion now. Now issuing 1.2 billion UIDs from a maximum
      possible space of 100 billion numbers implies that any UID
      chosen at random has a 1.2% probability of being a valid UID
      issued to someone. In other words, 1 out of every 83 possible
      UID values is a valid UID issued to someone. Therefore, these
      UIDs should not be treated as secret. It should be assumed that
      an adversary can easily guess valid UIDs issued to actual
      residents.
    </p>
    <p>
      Note that this problem gets worse as the population of India
      grows. Currently, it is growing at the rate of about 1.4% every
      year. The growth rate is expected to slow down in future. For
      now, I will assume that the growth rate is never going to exceed
      1.4% to get a conservative estimate. Then by the year 2050, the
      population of India would not exceed 2.1 billion. Then the
      probability that a randomly generated UID is an actual UID
      issued to a resident would increase to 2.1%.
    </p>
    <p>
      Therefore, any critical operation performed using a UID must
      perform an independent verification, such as two-factor
      authentication, SMS-based verification, etc. to ensure that the
      operation is approved by the actual resident the UID is issued
      to.
    </p>
  </li>
  <li>
    <p>
      <strong>UID static PIN and dynamic PIN</strong> (page 7):
    </p>
    <blockquote>
      In order to authenticate (ascertain it is who s/he claims to be) a
      resident needs to provide his/her UID number as well as say a
      biometric marker â€“ such as a fingerprint.
    </blockquote>
    <p>
      Using biometrics while issuing UIDs may be fine. But using
      biometrics for other important transactions might put the
      resident at risk. For example, see this BBC news story:
      <a href="http://web.archive.org/web/20050528103727/http://news.bbc.co.uk/2/hi/asia-pacific/4396831.stm">Malaysia Car Thieves Steal Finger</a>.
  </li>
  <li>
    <p>
      <strong>Principles and Requirements</strong> (page 11):
    </p>
    <blockquote>
      Number Generation: The numbers are generated in a random,
      non-repeating sequence. There are several approaches to doing
      this in the computer science literature. The algorithm and any
      "seed" chosen to generate IDs should not be made public and
      should be considered a national secret.
    </blockquote>
    <p>
      This violates Shannon's maxim, "The enemy knows the system." The
      security of the system must rely on the secrecy of the seed
      only. It must not depend on the secrecy of the algorithm.
      Further, as explained in point 2 above, an adversory can
      randomly generate 12 digit number with a high likelihood of it
      being an actual UID to a resident.
    </p>
  </li>
  <li>
    <p>
      <strong>The Checksum</strong> (page 12):
    </p>
    <blockquote>
      There is one scheme that meets our requirements: the Verhoeff
      Scheme. This scheme is relatively complex, and in the days
      before ubiquitous computing, there was a tendency to avoid it in
      favor of simpler schemes. In this day and age however, and at
      the scale of the UID, precision must be the goal. The Verhoeff
      scheme catches all single errors and all adjacent
      transpositions. It also catches >95% of twin errors and >94% of
      jump transpositions.
    </blockquote>
    <p>
      For those who are curious about what this scheme is, more information can be found at
      <a href="http://www.cs.utsa.edu/~wagner/laws/verhoeff.html">http://www.cs.utsa.edu/~wagner/laws/verhoeff.html</a>
      and <a href="http://en.wikipedia.org/wiki/Verhoeff_algorithm">http://en.wikipedia.org/wiki/Verhoeff_algorithm</a>.
    </p>
  </li>
</ol>
<p>
  <strong>Update on 31 May 2010:</strong> After an email conversation
  with Nandan Nilekani about the points I have documented in this blog
  post, he requested that I send these points in the form a document
  to him so that he can have it reviewed by his team. I have done so
  today.
</p>

<p><a href="https://susam.in/maze/uid-numbering-scheme.html">Read on website</a></p>
]]>
</description>
<pubDate>Mon, 24 May 2010 00:00:00 +0000</pubDate>
</item>
<item>
<title>OSVDB in GSoC</title>
<link>https://susam.in/maze/osvdb-in-gsoc.html</link>
<guid>https://susam.in/maze/osvdb-in-gsoc.html</guid>
<description>
<![CDATA[
<p>
  The Open Source Vulnerability Database (OSVDB) is participating in
  Google Summer of Code (GSoC) this year. I have been contributing to
  OSVDB as a <em>vulnerability mangler</em> since Aug 2006 and
  analyzing new vulnerabilities being published by security
  researchers, adding more details to them depending on the nature and
  severity of the vulnerabilities, and cataloging them. Our internal
  systems for cataloging vulnerabilities could use some help from more
  contributors, so it is great that OSVDB is participating in GSoC
  this year.
</p>
<p>
  Last month we selected some potential contributors from a pile of
  applications. One of them is Timothy F. Tutt Jr. who will be doing
  the Researcher Confidence Project for OSVDB.
</p>
<p>
  In the commenting system for OSVDB contributors, Brian Martin a.k.a.
  Jericho, one of the project leaders, wrote this comment that I found
  quite funny:
</p>
<blockquote>
  Don't think I need to argue how big this is to me, given the time I
  spend arguing with researchers and vendors. If we approve this and I
  am not the mentor, I will feed Jake to a woodchipper.
</blockquote>

<p><a href="https://susam.in/maze/osvdb-in-gsoc.html">Read on website</a></p>
]]>
</description>
<pubDate>Fri, 27 Apr 2007 00:00:00 +0000</pubDate>
</item>
<item>
<title>Volunteering for OSVDB</title>
<link>https://susam.in/maze/volunteering-for-osvdb.html</link>
<guid>https://susam.in/maze/volunteering-for-osvdb.html</guid>
<description>
<![CDATA[
<p>
  I am now an active Open Source Vulnerability Database (OSVDB)
  volunteer. I joined it on 06 Jun 2006. Although I enrolled as a
  volunteer there around 3 weeks, I worked on a vulnerability for the
  first time today. The vulnerability I picked for my first
  contribution
  was <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=2006-2971">0verkill
  recv_packet() Function UDP Handling Overflow DoS</a>. This is an
  integer underflow error in a Linux based gaming daemon called
  0verkill. It could be exploited to launch DoS attacks by sending UDP
  packets of size less than 12 bytes to the 0verkill daemon. An
  example exploit code is available
  at <a href="http://web.archive.org/web/20201208191904/https://www.securityfocus.com/archive/1/436659/100/0/threaded">this
  Bugtraq thread</a>.
</p>
<p>
  OSVDB is a project of the Open Security Foundation. Its goal is to
  provide accurate, unbiased information about security
  vulnerabilities in computerized equipment. The core of OSVDB is a
  relational database which ties various information about security
  vulnerabilities into a common, cross-referenced data source.
</p>
<p>
  In OSVDB, vulnerability reports, advisories, and exploits posted in
  various security lists enter the database as new entries. Each new
  entry contains only a title and links to entries of the same
  vulnerability in other security lists. However, a new entry does not
  contain any detailed description of the vulnerability. After the new
  entries are thoroughly scrutinized, analyzed, and refined by us, we
  add vulnerability description, technical description, solution
  description, manual testing notes, etc. Then these details on each
  entry are reviewed by other members of OSVDB, further refined if
  necessary, and then marked as stable entries. Once an entry for a
  vulnerability becomes stable, the detailed information for it
  appears on the page for the entry. One of the wonderful things that
  OSVDB brings to the world of security research is that each entry
  published on the OSVDB website has an extensive and almost
  exhaustive list of cross-references linking together all information
  about the vulnerability available on various security databases.
</p>

<p><a href="https://susam.in/maze/volunteering-for-osvdb.html">Read on website</a></p>
]]>
</description>
<pubDate>Sat, 24 Jun 2006 00:00:00 +0000</pubDate>
</item>
<item>
<title>%2E Trick</title>
<link>https://susam.in/maze/2e-trick.html</link>
<guid>https://susam.in/maze/2e-trick.html</guid>
<description>
<![CDATA[
<p>
  There are two interesting vulnerabilities in Microsoft IIS 3.0 that
  allow remote attackers to view the source code of dynamic web pages
  written using ASP. Both are related and both are due to improper
  input validation by IIS 3.0.
</p>

<h2 id="appending-dot">Appending Dot<a href="#appending-dot"></a></h2>
<p>
  The first vulnerability allows the client to retrieve the source
  code of an ASP script by simply appending a dot
  (i.e., <code>.</code>) to the end of the URL. For example, while an
  URL like
</p>
<pre><code>http://example.com/foo.asp</code></pre>
<p>
  shows the output
  of <code>foo.asp</code>, the same URL when modified
  to
</p>
<pre><code>http://example.com/foo.asp.</code></pre> shows its source
  code.
  See <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-1999-0154">CVE-1999-0154</a>
  and <a href="http://web.archive.org/web/19980220121004/http://ciac.llnl.gov/ciac/bulletins/h-48.shtml">CIAC:H-48</a>
  for more details on this issue.
</p>

<h2 id="replacing-dit-with-2e">Replacing Dot With %2E<a href="#replacing-dit-with-2e"></a></h2>
<p>
  The second vulnerability, discovered by Weld Pond, is an issue that
  was introduced when the first issue was fixed by Microsoft. This
  vulnerability allows a client to retrieve the source code of an ASP
  script by changing the dot in the filename with its URL-encoding,
  i.e., <code>%2e</code>. For example, while an URL like
</p>
<pre><code>http://example.com/foo.asp</code></pre>
<p>
  shows the output
  of <code>foo.asp</code>, the same URL when modified
  to
</p>
<pre><code>http://example.com/foo%2easp.</code></pre> shows its source
  code.
</p>
<p>
  Note that <code>2e</code> is the hexadecimal representation of the
  ASCII code of the dot character. Here is a tiny C program that
  demonstrates this:
</p>
<pre>
<code>#include &lt;stdio.h&gt;

int main()
{
    printf("'%c', %d, %#x\n", '.', '.', '.');
    return 0;
}</code>
</pre>
Here is the output:
<pre>
<samp>$ cc foo.c && ./a.out
'.', 46, 0x2e</samp>
</pre>
<p>
  See <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-1999-0253">CVE-1999-0253</a>
  and <a href="http://web.archive.org/web/20010309183310/http://www.securityfocus.com/bid/1814">BID:1814</a>
  for more details on this issue.
</p>

<p><a href="https://susam.in/maze/2e-trick.html">Read on website</a></p>
]]>
</description>
<pubDate>Sun, 09 Dec 2001 00:00:00 +0000</pubDate>
</item>


</channel>
</rss>
