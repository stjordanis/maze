<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
<title>Susam's Lisp Maze</title>
<link>https://susam.in/maze/</link>
<atom:link href="https://susam.in/maze/rss.xml"
           rel="self" type="application/rss+xml"/>
<description>Feed from Susam's Lisp Maze</description>

<item>
<title>The Epic Lisp Hack</title>
<link>https://susam.in/maze/epic-lisp-hack.html</link>
<guid>https://susam.in/maze/epic-lisp-hack.html</guid>
<description>
<![CDATA[
<p>
  There is a wonderful story about a legendary Lisp debugging story in
  the second chapter of the book <em>Practical Common Lisp</em> by
  Peter Seibel. Quoting the story here:
</p>
<blockquote>
  <p>
    An even more impressive instance of remote debugging occurred on
    NASA's 1998 Deep Space 1 mission. A half year after the space
    craft launched, a bit of Lisp code was going to control the
    spacecraft for two days while conducting a sequence of
    experiments. Unfortunately, a subtle race condition in the code
    had escaped detection during ground testing and was already in
    space. When the bug manifested in the wild--100 million miles away
    from Earth--the team was able to diagnose and fix the running
    code, allowing the experiments to complete. One of the
    programmers described it as follows:
  </p>
  <blockquote>
    <p>
      Debugging a program running on a $100M piece of hardware that is
      100 million miles away is an interesting experience. Having a
      read-eval-print loop running on the spacecraft proved invaluable
      in finding and fixing the problem.
    </p>
  </blockquote>
</blockquote>

<p><a href="https://susam.in/maze/epic-lisp-hack.html">Read on website</a></p>
]]>
</description>
<pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate>
</item>
<item>
<title>Building Common Lisp Executables</title>
<link>https://susam.in/maze/building-common-lisp-executables.html</link>
<guid>https://susam.in/maze/building-common-lisp-executables.html</guid>
<description>
<![CDATA[
<p>
  Since Common Lisp is a language standard (not an implementation) it
  is hard to provide a single set of instructions or guidelines that
  would work for all implementations. There are various
  implementations of Common Lisp that target native machine code, C
  code, bytecode, JVM, etc. So the build instructions, project
  structure, etc. depend on the target.
</p>

<h2 id="using-sbcl">Using SBCL<a href="#using-sbcl"></a></h2>
<p>
  Here is a minimal example that builds a Lisp program into a binary
  executable with SBCL:
</p>
<p>
<pre>
<code>(defun main ()
  (format t "hello, world~%"))
(sb-ext:save-lisp-and-die "hello" :executable t :toplevel #'main)</code>
</pre>
<p>
  The SBCL-specific <code>save-lisp-and-die</code> function saves the
  Lisp process as a core image. The <code>:executable t</code> keyword
  argument includes the SBCL runtime in the image to ensure that the
  image is a standalone executable. This is why the executable for
  even a simple hello-world program tends to be quite large (30 MB to
  50 MB)! The <code>:toplevel</code> argument specifies the function
  to run when the core file is run.
</p>
<p>
  Here are some example commands to get you started:
</p>
<pre>
<samp>$ <kbd>cat hello.lisp</kbd>
(defun main ()
  (format t "hello, world~%"))
(sb-ext:save-lisp-and-die "hello" :executable t :toplevel #'main)
$ <kbd>sbcl --load hello.lisp</kbd>
$ <kbd>./hello</kbd>
hello, world</samp>
</pre>

<h2 id="moving-unportable-code-to-command-line-argument">Moving Unportable Code to Command Line Argument<a href="#moving-unportable-code-to-command-line-argument"></a></h2>
<p>
  If you would rather not have SBCL specific code in the Lisp source
  code file, then you could move
  the <code>sb-ext:save-lisp-and-die</code> call out of your source
  file to the SBCL command invocation. The source code now looks like
  this:
</p>
<pre>
<samp>(defun main ()
  (format t "hello, world~%"))</samp>
</pre>
<p>
  The shell commands now look like this:
</p>
<pre>
<samp>$ <kbd>cat hello.lisp</kbd>
(defun main ()
  (format t "hello, world~%"))
$ <kbd>sbcl --load hello.lisp --eval "(sb-ext:save-lisp-and-die \"hello\" :executable t :toplevel #'main)"</kbd>
$ <kbd>./hello</kbd>
hello, world</samp>
</pre>

<h2 id="using-buildapp">Using Buildapp<a href="#using-buildapp"></a></h2>
<p>
  By the way, there is
  also <a href="https://www.xach.com/lisp/buildapp/">Buildapp</a> that
  provides a layer of abstraction for building executables from Lisp
  programs. It works with SBCL and CCL. It requires the toplevel
  function to be called with an argument though. Therefore the source
  code needs to be modified to the following:
</p>
<pre>
<code>(defun main (argv)
  (declare (ignore argv))
  (format t "hello, world~%"))</code>
</pre>
<p>
Then Buildapp can be invoked like this:
</p>
<pre>
<samp>$ <kbd>cat hello.lisp</kbd>
(defun main (argv)
  (declare (ignore argv))
  (format t "hello, world~%"))
$ <kbd>buildapp --load hello.lisp --entry main --output hello</kbd>
;; loading file #P"/Users/susam/hello.lisp"
$ <kbd>./hello</kbd>
hello, world</samp>
</pre>  

<p><a href="https://susam.in/maze/building-common-lisp-executables.html">Read on website</a></p>
]]>
</description>
<pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate>
</item>
<item>
<title>Zero Length Regular Expression</title>
<link>https://susam.in/maze/zero-length-regular-expression.html</link>
<guid>https://susam.in/maze/zero-length-regular-expression.html</guid>
<description>
<![CDATA[
<p>
  This post presents a list of how zero length regular expression is
  handled in various tools and programming languages. All of them
  compile the zero length regular expression pattern and the regular
  expression matches all strings.
</p>

<h2 id="gnu-grep">GNU grep<a href="#gnu-grep"></a></h2>
<pre>
<samp>$ <kbd>printf "foo\nbar\n" | grep ""</kbd>
foo
bar</samp>
</pre>

<h2 id="bsd-grep">BSD grep<a href="#bsd-grep"></a></h2>
<pre>
<samp>$ <kbd>printf "foo\nbar\n" | grep ""</kbd>
foo
bar</samp>
</pre>

<h2 id="perl">Perl<a href="#perl"></a></h2>
<pre>
<samp>$ <kbd>perl -e 'print(("foo" =~ //) .  "\n")'</kbd>
1</samp>
</pre>

<h2 id="python">Python<a href="#python"></a></h2>
<pre>
<samp>$ <kbd>python</kbd>
Python 2.5.2 (r252:60911, Jan  4 2009, 21:59:32)
[GCC 4.3.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; <kbd>import re; re.compile('').search('foo')</kbd>
&lt;_sre.SRE_Match object at 0x7fc6c5a2c510&gt;
</pre>

<h2 id="java">Java<a href="#java"></a></h2>
<pre>
<samp>$ <kbd>cat RegexExperiment.java</kbd>
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class RegexExperiment
{
    public static void main(String[] args)
    {
        System.out.println(Pattern.compile("").matcher("foo").find());
    }
}
$ <kbd>javac RegexExperiment.java && java RegexExperiment</kbd>
true</samp>
</pre>

<h2 id="mzscheme">MzScheme<a href="#mzscheme"></a></h2>
<pre>
<samp>$ <kbd>mzscheme</kbd>
Welcome to MzScheme v4.0.1 [3m], Copyright (c) 2004-2008 PLT Scheme Inc.
> <kbd>(regexp-match "" "foo")</kbd>
("")</samp>
</pre>

<h2 id="clisp">CLISP<a href="#clisp"></a></h2>
<pre>
<samp>$ <kbd>clisp</kbd>
  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo
  I I I I I I I      8     8   8           8     8     o  8    8
  I  \ `+' /  I      8         8           8     8        8    8
   \  `-+-'  /       8         8           8      ooooo   8oooo
    `-__|__-'        8         8           8           8  8
        |            8     o   8           8     o     8  8
  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8

Welcome to GNU CLISP 2.44.1 (2008-02-23) <http://clisp.cons.org/>

Copyright (c) Bruno Haible, Michael Stoll 1992, 1993
Copyright (c) Bruno Haible, Marcus Daniels 1994-1997
Copyright (c) Bruno Haible, Pierpaolo Bernardi, Sam Steingold 1998
Copyright (c) Bruno Haible, Sam Steingold 1999-2000
Copyright (c) Sam Steingold, Bruno Haible 2001-2008

Type :h and hit Enter for context help.

[1]> <kbd>(regexp:match "" "foo")</kbd>
#S(REGEXP:MATCH :START 0 :END 0)</samp>
</pre>

<h2 id="c">C<a href="#c"></a></h2>
<pre>
<samp>$ <kbd>ls -l /usr/lib/libpcre.so*</kbd>
lrwxrwxrwx 1 root root     17 May  3 15:15 /usr/lib/libpcre.so -> libpcre.so.3.12.1
lrwxrwxrwx 1 root root     17 Jan  6 14:57 /usr/lib/libpcre.so.3 -> libpcre.so.3.12.1
-rw-r--r-- 1 root root 162816 Jul 14  2008 /usr/lib/libpcre.so.3.12.1
susam@swift:~$ <kbd>cat pcre.c</kbd>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;pcre.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;pcre.h&gt;

int main(int argc, char **argv)
{
    pcre *p;
    char *re = "";
    char *s  = "foo";
    const char *errmsg;
    int errpos;
    int ovector[10];
    int ret;

    p = pcre_compile(re, 0, &amp;errmsg, &amp;errpos, NULL);
    ret = pcre_exec(p, NULL, s, strlen(s), 0, 0,
                    ovector, sizeof ovector / sizeof *ovector);

    printf(ret &lt; 0 ? "no match\n" : "match\n");
}
$ <kbd>cc -lpcre pcre.c && ./a.out</kbd>
match</samp>
</pre>

<p><a href="https://susam.in/maze/zero-length-regular-expression.html">Read on website</a></p>
]]>
</description>
<pubDate>Mon, 03 May 2010 00:00:00 +0000</pubDate>
</item>


</channel>
</rss>
